<!DOCTYPE html>
<html>
<head>
  <title>Wagyu Ribeye 3D</title>
  <style>
    body { margin: 0; background: linear-gradient(135deg, #2c1810, #4a2c20); }
    canvas { display: block; }
    #info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #d2691e;
      font-family: Arial, sans-serif;
      font-size: 12px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="info">Drag to rotate â€¢ Scroll to zoom</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Dramatic lighting for steak
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const warmLight = new THREE.SpotLight(0xff6b35, 0.8);
    warmLight.position.set(-3, 5, 2);
    scene.add(warmLight);

    // Create wooden board
    const boardGeometry = new THREE.BoxGeometry(4, 0.3, 3);
    const boardMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
    const board = new THREE.Mesh(boardGeometry, boardMaterial);
    board.position.y = -1.2;
    board.receiveShadow = true;
    scene.add(board);

    const group = new THREE.Group();

    // Main steak
    const steakGeometry = new THREE.BoxGeometry(2, 0.8, 1.5);
    steakGeometry.vertices?.forEach(vertex => {
      vertex.x += (Math.random() - 0.5) * 0.1;
      vertex.z += (Math.random() - 0.5) * 0.1;
    });
    
    const steakMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x8b0000,
      shininess: 20
    });
    const steak = new THREE.Mesh(steakGeometry, steakMaterial);
    steak.position.y = -0.6;
    steak.castShadow = true;

    // Grill marks
    const markGeometry = new THREE.PlaneGeometry(2.2, 0.1);
    const markMaterial = new THREE.MeshPhongMaterial({ color: 0x2f1b14 });
    
    for (let i = 0; i < 4; i++) {
      const mark = new THREE.Mesh(markGeometry, markMaterial);
      mark.position.y = -0.19;
      mark.position.z = -0.6 + (i * 0.4);
      mark.rotation.x = -Math.PI / 2;
      group.add(mark);
    }

    // Bone marrow
    const marrowGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
    const marrowMaterial = new THREE.MeshPhongMaterial({ color: 0xf5deb3 });
    const marrow = new THREE.Mesh(marrowGeometry, marrowMaterial);
    marrow.position.x = 1.5;
    marrow.position.y = -0.6;
    marrow.rotation.z = Math.PI / 2;
    marrow.castShadow = true;

    // Roasted vegetables
    const colors = [0x8B4513, 0xFF8C00, 0x228B22];
    for (let i = 0; i < 8; i++) {
      const vegGeometry = new THREE.SphereGeometry(0.2, 8, 8);
      const vegMaterial = new THREE.MeshPhongMaterial({ 
        color: colors[Math.floor(Math.random() * colors.length)]
      });
      const vegetable = new THREE.Mesh(vegGeometry, vegMaterial);
      
      vegetable.position.x = -1.5 + (Math.random() - 0.5) * 1;
      vegetable.position.z = (Math.random() - 0.5) * 2;
      vegetable.position.y = -0.8;
      vegetable.castShadow = true;
      
      group.add(vegetable);
    }

    group.add(steak);
    group.add(marrow);
    scene.add(group);
    
    camera.position.set(4, 3, 5);
    camera.lookAt(0, -0.5, 0);

    // Controls
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    document.addEventListener('mousedown', (e) => { isDragging = true; });
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaMove = {
          x: e.clientX - previousMousePosition.x,
          y: e.clientY - previousMousePosition.y
        };
        group.rotation.y += deltaMove.x * 0.01;
        group.rotation.x += deltaMove.y * 0.01;
      }
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    document.addEventListener('mouseup', () => { isDragging = false; });

    document.addEventListener('wheel', (e) => {
      camera.position.multiplyScalar(1 + e.deltaY * 0.001);
      camera.position.clampLength(3, 10);
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      if (!isDragging) {
        group.rotation.y += 0.003;
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>